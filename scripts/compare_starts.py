#!/usr/bin/env python3
"""Compare second-column coordinates between TXT and CSV outputs.

The TXT file comes from the original C implementation and stores 0-based starts
in column 2. This script converts them to 1-based positions to match the Rust
CSV and then reports mismatches. For each mismatch we also show the immediate
neighbor rows (previous/next) so it is easier to see whether the CSV is shifted
or the family grouping removed that entry entirely.
"""

from __future__ import annotations

import argparse
import csv
from dataclasses import dataclass
from pathlib import Path
from typing import List


@dataclass
class TxtEntry:
    row_num: int
    start0: int
    start1: int
    raw_line: str


def read_csv_starts(path: Path) -> List[int]:
    with path.open(newline="") as handle:
        reader = csv.DictReader(handle)
        return [int(row["start"]) for row in reader]


def read_txt_entries(path: Path) -> List[TxtEntry]:
    entries: List[TxtEntry] = []
    with path.open() as handle:
        for raw in handle:
            raw = raw.rstrip()
            if not raw:
                continue
            parts = raw.split()
            if not parts or not parts[0].isdigit():
                continue
            row_num = int(parts[0])
            start0 = int(parts[1])
            entries.append(
                TxtEntry(
                    row_num=row_num,
                    start0=start0,
                    start1=start0 + 1,
                    raw_line=raw,
                )
            )
    return entries


def format_neighbor(entries: List[TxtEntry], csv: List[int], idx: int) -> str:
    if idx < 0 or idx >= len(entries) or idx >= len(csv):
        return "<no neighbor>"
    txt = entries[idx]
    csv_start = csv[idx]
    status = "match" if txt.start1 == csv_start else "DIFF"
    return f"row {txt.row_num}: txt={txt.start1} csv={csv_start} ({status})"


def main() -> None:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("txt", type=Path, help="TXT file from the C implementation")
    parser.add_argument("csv", type=Path, help="CSV file generated by Rust")
    parser.add_argument(
        "--limit",
        type=int,
        default=20,
        help="Maximum number of mismatches to print (default: 20)",
    )
    args = parser.parse_args()

    csv_starts = read_csv_starts(args.csv)
    txt_entries = read_txt_entries(args.txt)

    min_len = min(len(csv_starts), len(txt_entries))
    mismatches = []
    for idx in range(min_len):
        if txt_entries[idx].start1 != csv_starts[idx]:
            mismatches.append(idx)

    print(f"CSV rows: {len(csv_starts)}")
    print(f"TXT rows: {len(txt_entries)}")
    print(f"Mismatches within shared prefix: {len(mismatches)}")
    if len(csv_starts) != len(txt_entries):
        print(
            "Note: files differ in length; extra rows exist beyond the common prefix."
        )

    for offset, idx in enumerate(mismatches[: args.limit]):
        txt = txt_entries[idx]
        csv_start = csv_starts[idx]
        print("-" * 72)
        print(
            f"Mismatch #{offset + 1} (row {txt.row_num}): txt start1={txt.start1}, csv start={csv_start}"
        )
        print(f"  raw TXT line: {txt.raw_line}")
        prev_info = format_neighbor(txt_entries, csv_starts, idx - 1)
        next_info = format_neighbor(txt_entries, csv_starts, idx + 1)
        print(f"  prev -> {prev_info}")
        print(f"  next -> {next_info}")

    if len(mismatches) > args.limit:
        print(
            f"... truncated output (showing first {args.limit} mismatches out of {len(mismatches)})"
        )


if __name__ == "__main__":
    main()
